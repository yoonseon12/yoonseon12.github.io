<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>YoonSeon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="YoonSeon">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="YoonSeon">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="YoonSeon" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YoonSeon</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-배열-큐-스택-링크드리스트" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/28/%EB%B0%B0%EC%97%B4-%ED%81%90-%EC%8A%A4%ED%83%9D-%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/" class="article-date">
  <time class="dt-published" datetime="2023-10-28T07:54:08.000Z" itemprop="datePublished">2023-10-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/28/%EB%B0%B0%EC%97%B4-%ED%81%90-%EC%8A%A4%ED%83%9D-%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/">배열, 큐, 스택, 링크드리스트</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>배열(Array)</li>
<li>큐(Queue)</li>
<li>스택(Stack)</li>
<li>링크드 리스트(LinkedList)</li>
<li>더블 링크드 리스트(Doubly LinkedList)</li>
</ol>
<hr>
<br>   

<h3 id="배열-Array"><a href="#배열-Array" class="headerlink" title="배열(Array)"></a>배열(Array)</h3><ul>
<li>데이터를 각 인덱스를 통해 할당한 데이터 구조로 같은 종류의 데이터를 효율적으로 관리하기 위해 사용한다.</li>
<li>장점 : 빠른 접근이 가능하다.</li>
<li>단점 : 배열 크기는 미리 설정해야하고 변경할 수 없다. 추가, 삭제가 쉽지 않다.<br></li>
</ul>
<h3 id="큐-Queue"><a href="#큐-Queue" class="headerlink" title="큐(Queue)"></a>큐(Queue)</h3><ul>
<li>먼저 들어간 자료가 먼저 나오는 구조 FIFO(First In FIrst Out) 구조이다. (ex.에스컬레이터)</li>
<li>운영체제에서 멀티 태스킹을 위한 프로세스 스케줄링 방식에 많이 사용된다.</li>
<li>Queue : 가장 일반적인 큐 자료 구조</li>
<li>PriorityQueue : 우선순위가 높은순으로 데이터를 출력하는 큐 자료 구조</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList; <span class="comment">//import</span></span><br><span class="line"><span class="keyword">import</span> java.util.Queue; <span class="comment">//import</span></span><br><span class="line">Queue&lt;String&gt; queue_str = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//String형 queue 선언, linkedlist 이용</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//int형 queue 선언</span></span><br><span class="line"></span><br><span class="line">queue.offer(<span class="number">1</span>);     <span class="comment">// queue에 값 1 추가</span></span><br><span class="line">queue.offer(<span class="number">2</span>);     <span class="comment">// queue에 값 2 추가</span></span><br><span class="line">queue.poll();       <span class="comment">// queue에 첫번째 값을 반환하고 제거 비어있다면 null</span></span><br><span class="line">queue.remove();     <span class="comment">// queue에 첫번째 값 제거</span></span><br><span class="line">queue.clear();      <span class="comment">// queue 초기화</span></span><br><span class="line">queue.peek();       <span class="comment">// queue의 첫번째 값 확인</span></span><br></pre></td></tr></table></figure>

<p><strong>자바에서는 왜 Queue를 ArrayList가 가인 linkedList로 구현해야할까?</strong></p>
<ul>
<li>ArrayList는 배열 기반의 자료 구조이기 떄문에 빈 공간을 채우기 위해서 데이터의 복사가 발생하므로 매우 비효율적이다. 하지만 LinkedList는 데이터 추가하거나 삭제할 때 요소 간의 링크만 조절하면 되므로 삽입 삭제가 효율적이다. 큐에서는 삽입, 삭제가 빈번하게 일어나기 때문에 대부분 LinkedList로 구현한다.<br></li>
</ul>
<h2 id="스택-Stack"><a href="#스택-Stack" class="headerlink" title="스택(Stack)"></a>스택(Stack)</h2><ul>
<li>가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조이다.(ex.책을 차곡차곡 쌓아올린 형태)</li>
<li>언제나 목록의 끝에서 접근할 수 있기 때문에 접근 방법이 제한적임</li>
<li>LIFO or FILO</li>
<li>스택의 대표적으로 활용 되는곳은 컴퓨터 내부의 프로세스 구조의 함수 동작 방식이 있다.<ul>
<li>재귀함수는 스택프레임을 사용하여 호출된 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소 값, 함수에서 선언된 지역 변수 등이 저장된다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack; <span class="comment">//import</span></span><br><span class="line">Stack&lt;String&gt; stack_str = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">//char형 스택 선언</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">//int형 스택 선언</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">1</span>);     <span class="comment">// stack에 값 1 추가</span></span><br><span class="line">stack.pop();       <span class="comment">// stack에 값 제거</span></span><br><span class="line">stack.clear();     <span class="comment">// stack의 전체 값 제거 (초기화)</span></span><br><span class="line">stack.peek();     <span class="comment">// stack의 가장 상단의 값 출력</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="링크드-리스트-LinkedList"><a href="#링크드-리스트-LinkedList" class="headerlink" title="링크드 리스트(LinkedList)"></a>링크드 리스트(LinkedList)</h2><ul>
<li>링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조</li>
<li>데이터의 저장단위인 노드와 각 노드에서 다음이나 이전 노드와 연결하는 공간인 포인터로 구성되있다.</li>
</ul>
<p><strong>링크드 리스트의 장단점</strong></p>
<ul>
<li>장점<ul>
<li>배열과 다르게 미리 데이터 공간을 할당하지 않아도됨</li>
</ul>
</li>
<li>단점<ul>
<li>연결을 위한 별도의 데이터 공간이 필요하므로, 저장공간 효율이 높지 않음</li>
<li>연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림</li>
<li>중간 데이터를 삭제할 경우 앞뒤 데이터의 연결을 재 구성 해야하는 작업이 필요함.</li>
</ul>
</li>
</ul>
<p><strong>그렇다면 링크드 리스트와 배열은 뭐가 다를까?</strong></p>
<ol>
<li>메모리 할당 구조<ol>
<li>배열은 순차적으로 연결된 공간에 데이터를 할당한다.</li>
<li>링크드 리스트는 연결된 노드로 데이터를 할당한다.</li>
</ol>
</li>
<li>크기<ol>
<li>배열은 데이터를 할당할 수 있는 크기가 고정되어 있다.</li>
<li>링크드 리스트는 동적 크기를 가지며 노드를 추가하거나 제거할 수 있다.</li>
</ol>
</li>
<li>메모리 사용량<ol>
<li>배열은 크기가 고정되어있기 때문에 비교적 메모리 사용량이 적다.</li>
<li>링크드 리스트는 연결을 위한 별도의 데이터 공간이 필요하므로, 메모리 사용량이 배열보다 높다.</li>
</ol>
</li>
<li>구현 복잡성<ol>
<li>배열은 비교적 간단하다.</li>
<li>노드를 생성하고 연결해야하기 때문에 복잡하다.</li>
</ol>
</li>
<li>연결 방법<ol>
<li>배열은 인덱스를 사용하여 요소를 연결한다.</li>
<li>링크드 리스트는 다음 노드에 대한 포인터를 사용한다.</li>
</ol>
</li>
</ol>
<p><strong>추가 함수 구현 로직</strong></p>
<ul>
<li>링크드 리스트 요소를 하기 위해서는 데이터와 데이터사이에 새로운 노드를 추가할 경우 앞 노드를 새로운 노드로 바꿔주고 새로운 노드의 주소를 다음 노드로 바꿔줘야한다.</li>
<li>만약 맨 앞의 노드(head)가 없다면 링크드 리스트가 없다고 판단하고 링크드 리스트의 제일 앞에 노드값을 넣는다.</li>
<li>만약 맨 앞의 노드(head)가 없지 않다면 노드를 next하여 마지막 노드까지 순회 후 마지막에 노드를 추가함.</li>
</ul>
<p><strong>삭제 함수 구현 로직</strong></p>
<ol>
<li>head 삭제 : 현재 head 노드 바로 다음 노드를 head로 변경하고 삭제한다. </li>
<li>중간 or 마지막 노드 삭제 : 삭제할 노드 이전 노드 포인터를 삭제할 노드 다음 노드의 포인터를 변경하고 삭제한다. 마지막 노드라면 다음 노드의 포인터가 없기때 문에 이전 노드의 포인터를 null로 변경하고 삭제한다.<br></li>
</ol>
<h2 id="더블-링크드-리스트-Doubly-LinkedList"><a href="#더블-링크드-리스트-Doubly-LinkedList" class="headerlink" title="더블 링크드 리스트(Doubly LinkedList)"></a>더블 링크드 리스트(Doubly LinkedList)</h2><p>각 노드가 이전 노드와 다음 노드를 가리킬 수 있는 포인터를 포함하고있다. 양방향으로 연결되어 있기 때문에 양 끝에서 찾으려는 노드에 접근할 수 있다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/28/%EB%B0%B0%EC%97%B4-%ED%81%90-%EC%8A%A4%ED%83%9D-%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/" data-id="clo9r0szu0000ud1iezm77gql" data-title="배열, 큐, 스택, 링크드리스트" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/" rel="tag">링크드리스트</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EB%B0%B0%EC%97%B4/" rel="tag">배열</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EC%8A%A4%ED%83%9D/" rel="tag">스택</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%ED%81%90/" rel="tag">큐</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-API-URL의-올바른-설계와-HTTP-메서드" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/" class="article-date">
  <time class="dt-published" datetime="2023-10-21T07:22:43.000Z" itemprop="datePublished">2023-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/">API URL의 올바른 설계와 HTTP 메서드</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="API-URL의-올바른-설계와-HTTP-메서드"><a href="#API-URL의-올바른-설계와-HTTP-메서드" class="headerlink" title="API URL의 올바른 설계와 HTTP 메서드"></a><strong>API URL의 올바른 설계와 HTTP 메서드</strong></h3><p><a href="#1">1. API URL의 올바른 설계</a></p>
<p><a href="#2">2. HTTP 메서드</a></p>
<p><a href="#3">3. HTTP 메서드의 속성</a></p>
<hr>
<h3 id="📌-API-URL의-올바른-설계"><a href="#📌-API-URL의-올바른-설계" class="headerlink" title="📌 API URL의 올바른 설계"></a><strong>📌</strong> <strong>API URL의 올바른 설계</strong></h3><p>많은 개발자들이 API의 URL을 설계할 때 다음과 같이 기능에 대한 이름으로 URL을 설계한다.</p>
<p><strong>회원 정보 관리 API 설계</strong></p>
<ul>
<li>회원 목록 조회 :  &#x2F;read-member-list</li>
<li>회원 조회 :  &#x2F;read-member-by-id</li>
<li>회원 등록 : &#x2F;create-member</li>
<li>회원 수정 : &#x2F;update-member</li>
<li>회원 삭제 : &#x2F;delete-member</li>
</ul>
<p>해당 API URL을 설계는 좋지 못한 설계이다. API URL 설계는 <strong>리소스와 행위를 구분하여</strong> 설계해야 한다. </p>
<p><strong>리소스(<strong>Resource</strong>)란</strong></p>
<p>리소스란 웹 상에서 고유한 식별자를 가지고 있는 모든 개별 항목을 나타낸다. HTTP 리소스는 클라이언트가 요청하고 서버가 응답하는 대상으로 일반적으로 웹 페이지, 이미지, 동영상, API 엔드포인트 등을 HTTP 리소스로 간주할 수 있다.</p>
<p>예를 들어 회원을 등록, 수정, 삭제, 조회한다면 회원이라는 개념 자체가 리소스이고 등록, 수정, 삭제, 조회가 행위인 것이다.</p>
<p><strong>리소스를 식별하여 다음과 같이 API URL을 재설계할 수 있다.</strong></p>
<ul>
<li>회원 목록 조회 :  &#x2F;members</li>
<li>회원 조회 :  &#x2F;members&#x2F;{id} </li>
<li>회원 등록 : &#x2F;members&#x2F;{id} </li>
<li>회원 수정 : &#x2F;members&#x2F;{id} </li>
<li>회원 삭제 : &#x2F;members&#x2F;{id}</li>
</ul>
<p> </p>
<blockquote>
<p><strong>참고 :</strong> 계층 구조상 상위를 컬렉션으로 보고 복수형 단어 사용을 권장한다.(member → members)</p>
</blockquote>
<p>API URL을 재설계를 했지만 중복된 API URL로 등록, 수정, 삭제, 조회의 행위가 구분되지 않는다.</p>
<p>행위를 구분하는 역할을 바로 HTTP 메서드가 한다.</p>
<h4 id="HTTP-메서드의-종류"><a href="#HTTP-메서드의-종류" class="headerlink" title="HTTP 메서드의 종류"></a><strong>HTTP 메서드의 종류</strong></h4><ul>
<li>주요 메서드<ul>
<li><strong>GET :</strong> 리소스를 조회한다.</li>
<li><strong>POST :</strong> 요청 데이터를 처리한다. 주로 등록 기능에 사용한다.</li>
<li><strong>PUT :</strong> 리소스가 있으면 대체하고 해당 리소스가 없으면 생성한다.</li>
<li><strong>PATCH :</strong> 리소스를 부분적으로 변경한다.</li>
<li><strong>DELETE :</strong> 리소스를 삭제한다.</li>
</ul>
</li>
<li>기타 메서드<ul>
<li><strong>HEAD :</strong> GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환</li>
<li><strong>OPTIONS :</strong> 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)</li>
<li>CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정</li>
<li>TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행</li>
</ul>
</li>
</ul>
<hr>
<h3 id="📌-HTTP-메서드"><a href="#📌-HTTP-메서드" class="headerlink" title="📌 HTTP 메서드"></a><strong>📌</strong> <strong>HTTP 메서드</strong></h3><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a><strong>GET</strong></h3><p>리소스를 조회 목적으로 <strong>데이터를 전달</strong>하는 방식</p>
<ul>
<li>서버에 전달하는 파라미터를 다음과 같이 쿼리 파라미터와 쿼리 스트링을 통해서 전달한다.<br>GET api&#x2F;patients?pageNo&#x3D;1&amp;pageSize&#x3D;3</li>
<li>메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아 권장하지 않는다.</li>
</ul>
<p><strong>GET 예시</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[요청]</span><br><span class="line">GET /member/100 HTTP/1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[응답]</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 34</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;young&quot;,</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>서버에서 클라이언트로 조회 결과를 응답메시지로 만들어 보낸다.</li>
</ul>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a><strong>POST</strong></h3><p>클라이언트에서 서버에 <strong>요청 데이터를 처리</strong> 목적으로 데이터를 전달하는 방식</p>
<ul>
<li>클라이언트가 메시지 바디를 통해 서버로 요청 데이터를 전달하고 서버는 요청 데이터를 처리하는 모든 기능을 수행한다.</li>
<li>주로 전달된 데이터로 신규 리소스를 등록, 프로세스 처리에 사용된다.</li>
<li>URL을 리소스와 행위만으로 생성하는데 제한이 있다면 컨트롤 URL로 생성한다.<br>예) POST &#x2F;orders&#x2F;{orderId}&#x2F;start-delivery (컨트롤 URL)</li>
<li>다른 메서드로 처리하기 애매한 경우에 사용한다.<ul>
<li>예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우</li>
<li>애매하면 POST를 사용하면 된다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>참고 :</strong> POST는 메시지를 외부에 보내는 모든 행위를 수행할 수 있지만 행위마다 약속된 HTTP 메서드가 더 많은 기능을 지원함으로 최대한 약속된 HTTP 메서드를 사용하도록 하고 정말 어쩔 수 없는 경우에만 POST로 사용하자.</p>
</blockquote>
<p><strong>POST 예시</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[요청 데이터]</span><br><span class="line">POST /members HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;young&quot;</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[응답 데이터]</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 34</span><br><span class="line">Location: /members/100</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;young&quot;</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>신규로 자원이 생산된 경로를 응답메시지로 보낸다.</li>
</ul>
<p>   </p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a><strong>PUT</strong></h3><p>리소스를 대체하는 방식</p>
<ul>
<li>리소스가 없으면 리소스를 생성한다.</li>
<li>리소스가 있으면 리소스를 완전히 대체한다.</li>
<li>쉽게 이야기해서 덮어버린다.</li>
<li><strong>클라이언트가 리소스를 식별한다. 즉, 클라이언트가 리소스 위치를 알고 URL을 지정한다.</strong></li>
</ul>
<blockquote>
<p>****참고 : POST와 PUT의 차이<br>****POST는 클라이언트가 리소스를 알지 못한 상태로 서버에 요청하고 서버는 데이터를 등록할  때 리소스를 생성한다.<br>PUT은 클라이언트가 리소스를 URL에 명시하여 서버에 데이터 처리를 요청한다.</p>
</blockquote>
<p><strong>PUT - 클라이언트에서 보낸 리소스가 서버에 없을 경우</strong></p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/cI4FKm/btsij9eAklG/VDJATK2NitoqkLOnlnvJCk/img.png" alt="PUT - 클라이언트에서 보낸 리소스가 서버에 없을 경우" title="PUT - 클라이언트에서 보낸 리소스가 서버에 없을 경우"></p>
<ul>
<li>클라이언트에서 보낸 리소스가 서버에 존재하지 않기 때문에 서버에서 클라이언트에서 보낸 리소스를 생성한다.</li>
</ul>
<p><strong>PUT - <strong>클라이언트에서 보낸 리소스가 서버에 있을 경우</strong></strong></p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/us8KG/btsiheHZS84/Ww7RS6E6vVQs6F29LKBnF1/img.png" alt="PUT - 클라이언트에서 보낸 리소스가 서버에 있을 경우" title="PUT - 클라이언트에서 보낸 리소스가 서버에 있을 경우"></p>
<ul>
<li>클라이언트에서 보낸 리소스가 서버에 존재하기 때문에 서버의 리소스가 클라이언트에서 보낸 리소스로 <strong>완전히 대체된다.</strong></li>
</ul>
<p><strong>PUT - 리소스를 완전히 대체한다는 것은</strong> </p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/ScHAX/btsikUnQZZ1/yaEQfYaW0PtQjFivUvmkSK/img.png" alt="PUT - 리소스를 완전히 대체한다는 것은" title="PUT - 리소스를 완전히 대체한다는 것은"></p>
<ul>
<li>PUT 메서드에서 가장 중요한 것은 리소스를 수정하는 것이 아니라 <strong>완전히 대체</strong>된다는 것이다. </li>
<li>클라이언트가 username 필드를 제외한 데이터를 서버로 보내면 서버에서는 username 필드가 있었다고 해도 username 필드가 삭제된다. 리소스를 <strong>완전히 대체하기 때문</strong>이다.</li>
</ul>
<h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a><strong>PATCH</strong></h3><p>리소스를 부분 변경하는 방식</p>
<ul>
<li>PUT과 다르게 리소스를 부분 변경하는 방식이기 때문에 데이터를 업데이트하는 데 사용한다.</li>
<li>PATCH를 지원하지 않는 서버의 경우 POST를 사용하면 된다.</li>
</ul>
<blockquote>
<p><strong>참고 : PATCH를 사용할 때 서버에 리소스가 없다면 리소스가 생성될까?</strong><br>PATCH 서버가 해당 리소스를 생성하도록 구현되어 있다면 리소스가 생성될 수도 있다. 그러나 일반적으로 PATCH 메서드는 기존 리소스를 업데이트하는 용도로 사용되며, 리소스를 생성하는 데는 POST나 PUT 메서드가 보다 적합하다.</p>
</blockquote>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a><strong>DELETE</strong></h3><p>리소스 제거한다.</p>
<ul>
<li>클라이언트에서 보낸 리소스를 서버에서 제거한다.</li>
</ul>
<hr>
<h3 id="📌-HTTP-메서드의-속성"><a href="#📌-HTTP-메서드의-속성" class="headerlink" title="📌 HTTP 메서드의 속성"></a><strong>📌</strong> <strong>HTTP 메서드의 속성</strong></h3><ul>
<li>안전성(Safe Methods)</li>
<li>멱등성(Idempotent Methods)</li>
<li>캐시가능(Cacheable Methods)</li>
</ul>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/ci0gd5/btsihdh4YcN/8mJWKXKr03RQEqIdUNIPKk/img.png" alt="HTTP 메서드의 속성" title="HTTP 메서드의 속성"></p>
<h4 id="안전성-Safe"><a href="#안전성-Safe" class="headerlink" title="**안전성(**Safe)"></a>**안전성(**<strong>Safe)</strong></h4><ul>
<li>클라이언트에서 서버를 호출해도 리소스를 변경하지 않는다.</li>
<li>안전은 해당 리소스만을 고려한다. 만약 계속 호출해서 로그가 수없이 쌓여 장애가 발생되는 경우는 고려하지 않는다.</li>
</ul>
<h4 id="멱등성-Idempotent"><a href="#멱등성-Idempotent" class="headerlink" title="**멱등성(**Idempotent)"></a>**멱등성(**<strong>Idempotent)</strong></h4><ul>
<li>한 번 호출하든 여러 번 호출하든 결과가 동일하다.</li>
<li>멱등은 외부 요인으로 중간에 리소스를 변경되어 조회되는 것 까지는 고려하지 않는다.<br>GET요청(기존의 데이터 조회) → PUT요청으로 기존의 데이터 수정 → GET 요청(변경된 데이터 조회)<br>이런 상황은 고려하지 않는다는 것이다. GET은 메서드 목적에 맞게 사용 시 동일한 결과가 조회되기 때문에 멱등성을 가진다.</li>
<li><strong>멱등성을 가진 HTTP 메서드(POST, PATCH 제외)</strong><ul>
<li><strong>GET :</strong> 리소스의 조회를 위해 사용되는 메서드로, 몇 번을 조회해도 같은 결과가 조회된다. 따라서 GET은 멱등성을 가진다.</li>
<li><strong>PUT :</strong> 리소스를 생성하거나 수정하기 위해 사용되는 메서드로, 동일한 리소스를 여러 번 PUT 요청하더라도 계속 동일하게 대체한다. 따라서 PUT도 멱등성을 가진다.</li>
<li><strong>DELETE :</strong> 리소스를 삭제하기 위해 사용되는 메서드로, 같은 리소스에 대해 여러 번 DELETE 요청을 보내도 삭제된 결과는 동일하다. 따라서 DELETE도 멱등성을 가진다.</li>
<li><strong>POST :</strong> 멱등이 아니다. 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.</li>
<li><strong>PATCH :</strong> 멱등으로 설계할 수 있지만 멱등이 아니게도 설계할 수 있다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>PUT과 다르게 PATCH가 멱등이 아닌 이유</strong> <br>멱등의 조건을 파악하는 것은 HTTP 메서드를 원래 목적에 맞게 올바르게 사용한 경우에 해당한다.  </p>
<p>PATCH  메서드의 목적은 부분적인 변경을 수행하고, 변경 방식이 자율적이며, 존재하지 않는 필드에 대한 업데이트도 허용한다. PATCH를 부분 변경을 동일하게 수행하도록 PUT처럼 사용한다면 멱등성을 보장하는 것이지만, PATCH가 허용하는 메서드의 목적 중 멱등성이 보장하지 않는 다른 방법으로 사용한다면 멱등성을 보장되지 않는 것이다.  </p>
<p>그렇기에 PATCH는 멱등성을 보장하지 않을 수도 있기 때문에 메서드의 원래 목적이 멱등성을 보장할 수도, 멱등성을 보장하지 않을 수도 있다.  </p>
<p>그러나, PUT 메서드는 리소스의 전체를 대체하는 업데이트를 수행하는 것이 목적이므로, 동일한 PUT 요청을 여러 번 실행하더라도 항상 동일한 상태로 리소스가 변경된다. PUT 메서드는 멱등성을 보장하는 것이 일반적인 규칙이다.  </p>
<p>반면 PUT의 경우 메서드의 목적 자체가 리소스를 대체하는 요청이기에, 정상적으로 사용한다면 멱등이며, PATCH처럼 사용을 했다면, 그 목적대로 사용하지 않았기 때문에 멱등이 되지 않을 수 있으나, 메서드의 목적에서 벗어나 잘못 사용한 것에 대해서는 고려하지 않는다.  </p>
<p>예를 들어 GET 메서드는 데이터 조회를 목적으로 하고, 서버의 상태를 변경하지 하기 때문에 멱등성을 가진다. 파라미터를 전송하여 내부 데이터 처리에 의해 서버 상태가 변경된다면, 이는 GET 메서드의 목적과는 맞지 않는 사용 방식이므로 멱등성을 보장하지 않는 것이다.  </p>
<p>각각의 HTTP 메서드는 그 목적과 의도에 따라 멱등성을 가지거나 가지지 않을 수 있다. 메서드를 올바르게 사용하고, 그 목적에 맞게 설계하면 멱등성을 보장할 수 있다.  </p>
</blockquote>
<h4 id="캐시가능"><a href="#캐시가능" class="headerlink" title="캐시가능"></a><strong>캐시가능</strong></h4><ul>
<li>웹 브라우저에 용량이 큰 이미지를 요청하면 다음에 똑같은 리소스를 요청할 필요가 없다. 만약, 같은 용량이 큰 이미지를 서버에서 내려받는다면 오래 걸릴 것이다. 그래서 리소스를 웹 브라우저의 로컬 저장소에 저장하고 다음 요청 시 서버에서 내려받는 것이 아니라 웹 브라우저가 사용하는 로컬 저장소에서 내려받는다. 이처럼 데이터나 값을 미리 복사해 놓는 임시 장소를 가리키는 것을 캐시라고 한다.</li>
<li>GET, HEAD, POST, PATCH 메서드는 스펙상 캐시 가능하다.</li>
<li>하지만 실무에서는 GET, HEAD 정도만 캐시로 사용한다.<br>POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데 구현이 쉽지 않다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/" data-id="clnzqc3kl0000331i85pzhio4" data-title="API URL의 올바른 설계와 HTTP 메서드" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/" rel="tag">링크드리스트</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%EB%B0%B0%EC%97%B4/" rel="tag">배열</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%EC%8A%A4%ED%83%9D/" rel="tag">스택</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%ED%81%90/" rel="tag">큐</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/" style="font-size: 10px;">링크드리스트</a> <a href="/tags/%EB%B0%B0%EC%97%B4/" style="font-size: 10px;">배열</a> <a href="/tags/%EC%8A%A4%ED%83%9D/" style="font-size: 10px;">스택</a> <a href="/tags/%ED%81%90/" style="font-size: 10px;">큐</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/28/%EB%B0%B0%EC%97%B4-%ED%81%90-%EC%8A%A4%ED%83%9D-%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8/">배열, 큐, 스택, 링크드리스트</a>
          </li>
        
          <li>
            <a href="/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/">API URL의 올바른 설계와 HTTP 메서드</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>