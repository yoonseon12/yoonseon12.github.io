<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>API URL의 올바른 설계와 HTTP 메서드 | Yoon 블로그</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="API URL의 올바른 설계와 HTTP 메서드1. API URL의 올바른 설계 2. HTTP 메서드 3. HTTP 메서드의 속성  📌 API URL의 올바른 설계많은 개발자들이 API의 URL을 설계할 때 다음과 같이 기능에 대한 이름으로 URL을 설계한다. 회원 정보 관리 API 설계  회원 목록 조회 :  &#x2F;read-member-list 회원">
<meta property="og:type" content="article">
<meta property="og:title" content="API URL의 올바른 설계와 HTTP 메서드">
<meta property="og:url" content="http://example.com/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/index.html">
<meta property="og:site_name" content="Yoon 블로그">
<meta property="og:description" content="API URL의 올바른 설계와 HTTP 메서드1. API URL의 올바른 설계 2. HTTP 메서드 3. HTTP 메서드의 속성  📌 API URL의 올바른 설계많은 개발자들이 API의 URL을 설계할 때 다음과 같이 기능에 대한 이름으로 URL을 설계한다. 회원 정보 관리 API 설계  회원 목록 조회 :  &#x2F;read-member-list 회원">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-21T07:22:43.000Z">
<meta property="article:modified_time" content="2023-10-21T07:23:34.730Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Yoon 블로그" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yoon 블로그</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-API-URL의-올바른-설계와-HTTP-메서드" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/" class="article-date">
  <time class="dt-published" datetime="2023-10-21T07:22:43.000Z" itemprop="datePublished">2023-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      API URL의 올바른 설계와 HTTP 메서드
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="API-URL의-올바른-설계와-HTTP-메서드"><a href="#API-URL의-올바른-설계와-HTTP-메서드" class="headerlink" title="API URL의 올바른 설계와 HTTP 메서드"></a><strong>API URL의 올바른 설계와 HTTP 메서드</strong></h3><p><a href="#1">1. API URL의 올바른 설계</a></p>
<p><a href="#2">2. HTTP 메서드</a></p>
<p><a href="#3">3. HTTP 메서드의 속성</a></p>
<hr>
<h3 id="📌-API-URL의-올바른-설계"><a href="#📌-API-URL의-올바른-설계" class="headerlink" title="📌 API URL의 올바른 설계"></a><strong>📌</strong> <strong>API URL의 올바른 설계</strong></h3><p>많은 개발자들이 API의 URL을 설계할 때 다음과 같이 기능에 대한 이름으로 URL을 설계한다.</p>
<p><strong>회원 정보 관리 API 설계</strong></p>
<ul>
<li>회원 목록 조회 :  &#x2F;read-member-list</li>
<li>회원 조회 :  &#x2F;read-member-by-id</li>
<li>회원 등록 : &#x2F;create-member</li>
<li>회원 수정 : &#x2F;update-member</li>
<li>회원 삭제 : &#x2F;delete-member</li>
</ul>
<p>해당 API URL을 설계는 좋지 못한 설계이다. API URL 설계는 <strong>리소스와 행위를 구분하여</strong> 설계해야 한다. </p>
<p><strong>리소스(<strong>Resource</strong>)란</strong></p>
<p>리소스란 웹 상에서 고유한 식별자를 가지고 있는 모든 개별 항목을 나타낸다. HTTP 리소스는 클라이언트가 요청하고 서버가 응답하는 대상으로 일반적으로 웹 페이지, 이미지, 동영상, API 엔드포인트 등을 HTTP 리소스로 간주할 수 있다.</p>
<p>예를 들어 회원을 등록, 수정, 삭제, 조회한다면 회원이라는 개념 자체가 리소스이고 등록, 수정, 삭제, 조회가 행위인 것이다.</p>
<p><strong>리소스를 식별하여 다음과 같이 API URL을 재설계할 수 있다.</strong></p>
<ul>
<li>회원 목록 조회 :  &#x2F;members</li>
<li>회원 조회 :  &#x2F;members&#x2F;{id} </li>
<li>회원 등록 : &#x2F;members&#x2F;{id} </li>
<li>회원 수정 : &#x2F;members&#x2F;{id} </li>
<li>회원 삭제 : &#x2F;members&#x2F;{id}</li>
</ul>
<p> </p>
<blockquote>
<p><strong>참고 :</strong> 계층 구조상 상위를 컬렉션으로 보고 복수형 단어 사용을 권장한다.(member → members)</p>
</blockquote>
<p>API URL을 재설계를 했지만 중복된 API URL로 등록, 수정, 삭제, 조회의 행위가 구분되지 않는다.</p>
<p>행위를 구분하는 역할을 바로 HTTP 메서드가 한다.</p>
<h4 id="HTTP-메서드의-종류"><a href="#HTTP-메서드의-종류" class="headerlink" title="HTTP 메서드의 종류"></a><strong>HTTP 메서드의 종류</strong></h4><ul>
<li>주요 메서드<ul>
<li><strong>GET :</strong> 리소스를 조회한다.</li>
<li><strong>POST :</strong> 요청 데이터를 처리한다. 주로 등록 기능에 사용한다.</li>
<li><strong>PUT :</strong> 리소스가 있으면 대체하고 해당 리소스가 없으면 생성한다.</li>
<li><strong>PATCH :</strong> 리소스를 부분적으로 변경한다.</li>
<li><strong>DELETE :</strong> 리소스를 삭제한다.</li>
</ul>
</li>
<li>기타 메서드<ul>
<li><strong>HEAD :</strong> GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환</li>
<li><strong>OPTIONS :</strong> 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)</li>
<li>CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정</li>
<li>TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행</li>
</ul>
</li>
</ul>
<hr>
<h3 id="📌-HTTP-메서드"><a href="#📌-HTTP-메서드" class="headerlink" title="📌 HTTP 메서드"></a><strong>📌</strong> <strong>HTTP 메서드</strong></h3><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a><strong>GET</strong></h3><p>리소스를 조회 목적으로 <strong>데이터를 전달</strong>하는 방식</p>
<ul>
<li>서버에 전달하는 파라미터를 다음과 같이 쿼리 파라미터와 쿼리 스트링을 통해서 전달한다.<br>GET api&#x2F;patients?pageNo&#x3D;1&amp;pageSize&#x3D;3</li>
<li>메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아 권장하지 않는다.</li>
</ul>
<p><strong>GET 예시</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[요청]</span><br><span class="line">GET /member/100 HTTP/1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[응답]</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 34</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;young&quot;,</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>서버에서 클라이언트로 조회 결과를 응답메시지로 만들어 보낸다.</li>
</ul>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a><strong>POST</strong></h3><p>클라이언트에서 서버에 <strong>요청 데이터를 처리</strong> 목적으로 데이터를 전달하는 방식</p>
<ul>
<li>클라이언트가 메시지 바디를 통해 서버로 요청 데이터를 전달하고 서버는 요청 데이터를 처리하는 모든 기능을 수행한다.</li>
<li>주로 전달된 데이터로 신규 리소스를 등록, 프로세스 처리에 사용된다.</li>
<li>URL을 리소스와 행위만으로 생성하는데 제한이 있다면 컨트롤 URL로 생성한다.<br>예) POST &#x2F;orders&#x2F;{orderId}&#x2F;start-delivery (컨트롤 URL)</li>
<li>다른 메서드로 처리하기 애매한 경우에 사용한다.<ul>
<li>예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우</li>
<li>애매하면 POST를 사용하면 된다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>참고 :</strong> POST는 메시지를 외부에 보내는 모든 행위를 수행할 수 있지만 행위마다 약속된 HTTP 메서드가 더 많은 기능을 지원함으로 최대한 약속된 HTTP 메서드를 사용하도록 하고 정말 어쩔 수 없는 경우에만 POST로 사용하자.</p>
</blockquote>
<p><strong>POST 예시</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[요청 데이터]</span><br><span class="line">POST /members HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;young&quot;</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[응답 데이터]</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 34</span><br><span class="line">Location: /members/100</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;young&quot;</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>신규로 자원이 생산된 경로를 응답메시지로 보낸다.</li>
</ul>
<p>   </p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a><strong>PUT</strong></h3><p>리소스를 대체하는 방식</p>
<ul>
<li>리소스가 없으면 리소스를 생성한다.</li>
<li>리소스가 있으면 리소스를 완전히 대체한다.</li>
<li>쉽게 이야기해서 덮어버린다.</li>
<li><strong>클라이언트가 리소스를 식별한다. 즉, 클라이언트가 리소스 위치를 알고 URL을 지정한다.</strong></li>
</ul>
<blockquote>
<p>****참고 : POST와 PUT의 차이<br>****POST는 클라이언트가 리소스를 알지 못한 상태로 서버에 요청하고 서버는 데이터를 등록할  때 리소스를 생성한다.<br>PUT은 클라이언트가 리소스를 URL에 명시하여 서버에 데이터 처리를 요청한다.</p>
</blockquote>
<p><strong>PUT - 클라이언트에서 보낸 리소스가 서버에 없을 경우</strong></p>
<p>[##<em>Image|kage@2Yo98&#x2F;btsikBvo8nM&#x2F;9YJC3P7zc4RnJ511fEvmAk&#x2F;img.png|CDM|1.3|{“originWidth”:846,”originHeight”:382,”style”:”alignCenter”,”width”:580,”height”:262}</em>##][##<em>Image|kage@cI4FKm&#x2F;btsij9eAklG&#x2F;VDJATK2NitoqkLOnlnvJCk&#x2F;img.png|CDM|1.3|{“originWidth”:792,”originHeight”:366,”style”:”alignCenter”,”width”:576,”height”:266}</em>##]</p>
<ul>
<li>클라이언트에서 보낸 리소스가 서버에 존재하지 않기 때문에 서버에서 클라이언트에서 보낸 리소스를 생성한다.</li>
</ul>
<p><strong>PUT - <strong>클라이언트에서 보낸 리소스가 서버에 있을 경우</strong></strong></p>
<p>[##<em>Image|kage@us8KG&#x2F;btsiheHZS84&#x2F;Ww7RS6E6vVQs6F29LKBnF1&#x2F;img.png|CDM|1.3|{“originWidth”:787,”originHeight”:365,”style”:”alignCenter”,”width”:505,”height”:234}</em>##][##<em>Image|kage@bDeEuy&#x2F;btsilj2k9Ky&#x2F;itpkhQ9FCC93aREn1PE0y0&#x2F;img.png|CDM|1.3|{“originWidth”:829,”originHeight”:376,”style”:”alignCenter”,”width”:534,”height”:242}</em>##]</p>
<ul>
<li>클라이언트에서 보낸 리소스가 서버에 존재하기 때문에 서버의 리소스가 클라이언트에서 보낸 리소스로 <strong>완전히 대체된다.</strong></li>
</ul>
<p><strong>PUT - 리소스를 완전히 대체한다는 것은</strong> </p>
<p>[##<em>Image|kage@ScHAX&#x2F;btsikUnQZZ1&#x2F;yaEQfYaW0PtQjFivUvmkSK&#x2F;img.png|CDM|1.3|{“originWidth”:874,”originHeight”:370,”style”:”alignCenter”,”width”:558,”height”:236}</em>##][##<em>Image|kage@bwdlnJ&#x2F;btsinYQFUxc&#x2F;TT3rJ0sckMYOChHd9L0Az1&#x2F;img.png|CDM|1.3|{“originWidth”:857,”originHeight”:393,”style”:”alignCenter”,”width”:598,”height”:274}</em>##]</p>
<ul>
<li>PUT 메서드에서 가장 중요한 것은 리소스를 수정하는 것이 아니라 <strong>완전히 대체</strong>된다는 것이다. </li>
<li>클라이언트가 username 필드를 제외한 데이터를 서버로 보내면 서버에서는 username 필드가 있었다고 해도 username 필드가 삭제된다. 리소스를 <strong>완전히 대체하기 때문</strong>이다.</li>
</ul>
<h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a><strong>PATCH</strong></h3><p>리소스를 부분 변경하는 방식</p>
<ul>
<li>PUT과 다르게 리소스를 부분 변경하는 방식이기 때문에 데이터를 업데이트하는 데 사용한다.</li>
<li>PATCH를 지원하지 않는 서버의 경우 POST를 사용하면 된다.</li>
</ul>
<blockquote>
<p><strong>참고 : PATCH를 사용할 때 서버에 리소스가 없다면 리소스가 생성될까?</strong><br>PATCH 서버가 해당 리소스를 생성하도록 구현되어 있다면 리소스가 생성될 수도 있다. 그러나 일반적으로 PATCH 메서드는 기존 리소스를 업데이트하는 용도로 사용되며, 리소스를 생성하는 데는 POST나 PUT 메서드가 보다 적합하다.</p>
</blockquote>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a><strong>DELETE</strong></h3><p>리소스 제거한다.</p>
<ul>
<li>클라이언트에서 보낸 리소스를 서버에서 제거한다.</li>
</ul>
<hr>
<h3 id="📌-HTTP-메서드의-속성"><a href="#📌-HTTP-메서드의-속성" class="headerlink" title="📌 HTTP 메서드의 속성"></a><strong>📌</strong> <strong>HTTP 메서드의 속성</strong></h3><ul>
<li>안전성(Safe Methods)</li>
<li>멱등성(Idempotent Methods)</li>
<li>캐시가능(Cacheable Methods)</li>
</ul>
<p>[##<em>Image|kage@ci0gd5&#x2F;btsihdh4YcN&#x2F;8mJWKXKr03RQEqIdUNIPKk&#x2F;img.png|CDM|1.3|{“originWidth”:1500,”originHeight”:610,”style”:”alignCenter”}</em>##]</p>
<h4 id="안전성-Safe"><a href="#안전성-Safe" class="headerlink" title="**안전성(**Safe)"></a>**안전성(**<strong>Safe)</strong></h4><ul>
<li>클라이언트에서 서버를 호출해도 리소스를 변경하지 않는다.</li>
<li>안전은 해당 리소스만을 고려한다. 만약 계속 호출해서 로그가 수없이 쌓여 장애가 발생되는 경우는 고려하지 않는다.</li>
</ul>
<h4 id="멱등성-Idempotent"><a href="#멱등성-Idempotent" class="headerlink" title="**멱등성(**Idempotent)"></a>**멱등성(**<strong>Idempotent)</strong></h4><ul>
<li>한 번 호출하든 여러 번 호출하든 결과가 동일하다.</li>
<li>멱등은 외부 요인으로 중간에 리소스를 변경되어 조회되는 것 까지는 고려하지 않는다.<br>GET요청(기존의 데이터 조회) → PUT요청으로 기존의 데이터 수정 → GET 요청(변경된 데이터 조회)<br>이런 상황은 고려하지 않는다는 것이다. GET은 메서드 목적에 맞게 사용 시 동일한 결과가 조회되기 때문에 멱등성을 가진다.</li>
<li><strong>멱등성을 가진 HTTP 메서드(POST, PATCH 제외)</strong><ul>
<li><strong>GET :</strong> 리소스의 조회를 위해 사용되는 메서드로, 몇 번을 조회해도 같은 결과가 조회된다. 따라서 GET은 멱등성을 가진다.</li>
<li><strong>PUT :</strong> 리소스를 생성하거나 수정하기 위해 사용되는 메서드로, 동일한 리소스를 여러 번 PUT 요청하더라도 계속 동일하게 대체한다. 따라서 PUT도 멱등성을 가진다.</li>
<li><strong>DELETE :</strong> 리소스를 삭제하기 위해 사용되는 메서드로, 같은 리소스에 대해 여러 번 DELETE 요청을 보내도 삭제된 결과는 동일하다. 따라서 DELETE도 멱등성을 가진다.</li>
<li><strong>POST :</strong> 멱등이 아니다. 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.</li>
<li><strong>PATCH :</strong> 멱등으로 설계할 수 있지만 멱등이 아니게도 설계할 수 있다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>PUT과 다르게 PATCH가 멱등이 아닌 이유</strong> <br>멱등의 조건을 파악하는 것은 HTTP 메서드를 원래 목적에 맞게 올바르게 사용한 경우에 해당한다.  </p>
<p>PATCH  메서드의 목적은 부분적인 변경을 수행하고, 변경 방식이 자율적이며, 존재하지 않는 필드에 대한 업데이트도 허용한다. PATCH를 부분 변경을 동일하게 수행하도록 PUT처럼 사용한다면 멱등성을 보장하는 것이지만, PATCH가 허용하는 메서드의 목적 중 멱등성이 보장하지 않는 다른 방법으로 사용한다면 멱등성을 보장되지 않는 것이다.  </p>
<p>그렇기에 PATCH는 멱등성을 보장하지 않을 수도 있기 때문에 메서드의 원래 목적이 멱등성을 보장할 수도, 멱등성을 보장하지 않을 수도 있다.  </p>
<p>그러나, PUT 메서드는 리소스의 전체를 대체하는 업데이트를 수행하는 것이 목적이므로, 동일한 PUT 요청을 여러 번 실행하더라도 항상 동일한 상태로 리소스가 변경된다. PUT 메서드는 멱등성을 보장하는 것이 일반적인 규칙이다.  </p>
<p>반면 PUT의 경우 메서드의 목적 자체가 리소스를 대체하는 요청이기에, 정상적으로 사용한다면 멱등이며, PATCH처럼 사용을 했다면, 그 목적대로 사용하지 않았기 때문에 멱등이 되지 않을 수 있으나, 메서드의 목적에서 벗어나 잘못 사용한 것에 대해서는 고려하지 않는다.  </p>
<p>예를 들어 GET 메서드는 데이터 조회를 목적으로 하고, 서버의 상태를 변경하지 하기 때문에 멱등성을 가진다. 파라미터를 전송하여 내부 데이터 처리에 의해 서버 상태가 변경된다면, 이는 GET 메서드의 목적과는 맞지 않는 사용 방식이므로 멱등성을 보장하지 않는 것이다.  </p>
<p>각각의 HTTP 메서드는 그 목적과 의도에 따라 멱등성을 가지거나 가지지 않을 수 있다. 메서드를 올바르게 사용하고, 그 목적에 맞게 설계하면 멱등성을 보장할 수 있다.  </p>
</blockquote>
<h4 id="캐시가능"><a href="#캐시가능" class="headerlink" title="캐시가능"></a><strong>캐시가능</strong></h4><ul>
<li>웹 브라우저에 용량이 큰 이미지를 요청하면 다음에 똑같은 리소스를 요청할 필요가 없다. 만약, 같은 용량이 큰 이미지를 서버에서 내려받는다면 오래 걸릴 것이다. 그래서 리소스를 웹 브라우저의 로컬 저장소에 저장하고 다음 요청 시 서버에서 내려받는 것이 아니라 웹 브라우저가 사용하는 로컬 저장소에서 내려받는다. 이처럼 데이터나 값을 미리 복사해 놓는 임시 장소를 가리키는 것을 캐시라고 한다.</li>
<li>GET, HEAD, POST, PATCH 메서드는 스펙상 캐시 가능하다.</li>
<li>하지만 실무에서는 GET, HEAD 정도만 캐시로 사용한다.<br>POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데 구현이 쉽지 않다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/" data-id="clnzqc3kl0000331i85pzhio4" data-title="API URL의 올바른 설계와 HTTP 메서드" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/21/API-URL%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%84%A4%EA%B3%84%EC%99%80-HTTP-%EB%A9%94%EC%84%9C%EB%93%9C/">API URL의 올바른 설계와 HTTP 메서드</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>